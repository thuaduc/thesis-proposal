\section{Introduction}

A concurrent range lock is a dynamic fine-grained lock abstraction. It is designed to address the problem of multiple writers attempting to modify different parts of the same file. Unlike conventional methods that rely on a singular lock for the entire file, range lock enables concurrent access to disjoint parts of the file, thus allowing parallelism for writers and solving the bottleneck of using a singular lock. 

\section{Motivation}
Recently, there has been an increase in interest in range locking techniques \parencite{readerWriterLocks2017, mapleTree2021, mmapLock2022}. One notable example is that the Linux kernel community is considering using range-locking techniques to replace the \texttt{mmap\_lock}. The \texttt{mmap\_lock} uses a per-process semaphore to control access to the whole \texttt{mm\_struct}\parencite{mmstruct2023} and serialize changes to address spaces. There have been several attempts to overcome the scalability issues of \texttt{mmap\_lock}, but the problem is far from solved\parencite{mmapLock2022}.

In database management systems context, range locks also offer a solution to the issue of coarse-grained locking in large databases and indexes. Instead of locking entire indexes, range locks focus on key ranges, reducing contention and improving concurrency. This allows multiple transactions to operate concurrently on separate key ranges, alleviating memory overhead and lock acquisition bottlenecks \parencite{Graefe2020}.

\section{Related Work}
Previous research has explored various approaches to scalable range lock. One approach uses a skip list combined with a spin lock to dynamically maintain currently locked ranges\parencite{migrationWM2023}. The skip list is not as heavy as an interval tree or segment tree, but is still sufficient for intensive searches for existing overlapping ranges.

A different approach to range lock is to build it based on a linked-list instead of a range tree, where each node represents an acquired range\parencite{scalableRangeLock2020}. Although using a list makes it achievable to maintain lock-less range lock, inserting and searching operations on the linked list are likely less efficient.

\section{Approach}
The proposed approach is to design and implement a concurrent scope lock based on a probabilistic concurrent skip list data structure. Unlike conventional skip list, the proposed approach would use the requesting range \texttt{[start, end]} as the key per node and also utilize the per-node lock technique. This method will improve concurrency and performance while keeping the structure secure.

\section{Evaluation}
The proposed approach will be evaluated under these evaluation criteria:
\begin{itemize}
    \item Performance: It is necessary to measure the performance and throughput of the range locking mechanism under increasing load and concurrent accesses.
    \item Correctness: It is also crucial to validate the consistency and correctness of data accesses, especially in scenarios involving overlapping data ranges and concurrent operations.
    \item Comparison: A comparison must be made between the performance of the proposed solution and those of existing state-of-the-art approaches.
\end{itemize}

\section{Expected Outcome}
The expected outcome of this research is a scalable range-locking mechanism that improves the efficiency of the existing range locks. The findings from the evaluation will provide insights into the performance characteristics, and potential trade-offs of the proposed mechanism, contributing to the advancement of distributed computing research.

\section{Resources}
A thorough evaluation of the proposed mechanism requires a budget of 32 cores and 32 GB of RAM for one month. These resources allow for exhaustive testing under heavy contention, pushing the range lock to its limits and revealing its performance in multithreaded scenarios.